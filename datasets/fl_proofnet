{f : â„‚ â†’ â„‚} (Î© : Set â„‚) (h : IsOpen Î©) (hf : DifferentiableOn â„‚ f Î©)(hi : âˆƒ (c : â„), âˆ€ z âˆˆ Î©, (f z).im = c) : âˆ€ a b, f a = f b := 
{f : â„‚ â†’ â„‚} (Î© : Set â„‚) (h : IsOpen Î©) (hf : DifferentiableOn â„‚ f Î©)(hi : âˆƒ (c : â„), âˆ€ z âˆˆ Î©, (f z).im = c) : âˆ€ a b, f a = f b := 
{f : â„‚ â†’ â„‚} (Î© : Set â„‚) (h : IsOpen Î©) (hf : DifferentiableOn â„‚ f Î©)(hi : âˆƒ (c : â„), âˆ€ z âˆˆ Î©, (f z).im = c) : âˆ€ a b, f a = f b := 
(s : â„• â†’ â„‚) (h : s = (Î» n => âˆ‘ i in (range n), i * z ^ i)) : (z : â„‚) (hz : abs z = 1) Â¬âˆƒ y, Tendsto s atTop (ğ“ y) := 
(s : â„• â†’ â„‚) (h : s = (Î» n => âˆ‘ i in (range n), i * z / i))(z : â„‚) (hz : abs z = 1 âˆ§ z â‰  1) âˆƒ y, Tendsto s atTop (ğ“ y)(hz1 : z â‰  1) : (z : â„‚) (hz : abs z = 1) := 
 : âˆ« x in (0 : â„)..âˆ, Real.sin x / x = Real.pi / 2 := 
(f : â„‚ â†’ â„‚) [analytic_on â„‚ f]âˆ€ z0 : â„‚, âˆƒ n : â„•, (c n : â„‚) (f z0 = âˆ‘' n, c n * (z - z0) ^ n) âˆ§ c n = 0 : âˆƒ p : polynomial â„‚, âˆ€ z : â„‚, f z = polynomial.eval z p := 
(a : â„) (ha : 0 < a) : Tendsto (Î» y => âˆ« x in -y..y, x * Real.sin x / (x ^ 2 + a ^ 2)) atTop (ğ“ (Real.pi * Real.exp (-a))) := 
(he : Entire f) (hg : Entire g)(h : Injective h) : (f : â„‚ â†’ â„‚) (a b : â„‚) (h : f = Î» z, a * z + b) (ha : a â‰  0) := 
{f : â„‚ â†’ â„‚} (h : DifferentiableOn â„‚ f (Metric.ball 0 1))(hf : âˆƒ M, âˆ€ x, abs (f x) â‰¤ M)(hf4 : Â¬âˆ€ z, f z = 0)(hz : âˆ€ k, f z k = 0 âˆ§ â€–z kâ€– < 1) : lemma tsum_lt_infty : âˆ‘' n, (1 - |z n|) < âˆ := := 
(r : â„š)Â¬ âˆƒ (a b : â„¤), b â‰  0 âˆ§ x = a / b : (Irrational x) -> Irrational (r * x) := 
{E : Set Î±} [PartialOrder Î±] (hE : E.Nonempty)(hlb : âˆ€ x âˆˆ E, Î± â‰¤ x)(hub : âˆ€ x âˆˆ E, x â‰¤ Î²) : Î± â‰¤ Î² := 
 : Â¬âˆƒ (R : Type) [IsField R] [LinearOrder R], R = â„‚ := 
(z : Fin n â†’ â„‚) : abs (âˆ‘ i, z i) â‰¤ âˆ‘ i, abs (z i) := 
(z : â„‚)(hz : â€–zâ€– = 1)(hz1 : z * conj z = 1) : â€–1 + zâ€–^2 + â€–1 - zâ€–^2 := 
(x y : EuclideanSpace â„ (Fin n)) : abs (x + y) ^ 2 + abs (x - y) ^ 2 = 2 * abs x ^ 2 + 2 * abs y ^ 2 := 
if h : k = 1 then (x : EuclideanSpace â„ (Fin k)) : Â¬ âˆƒ (y : EuclideanSpace â„ (Fin k)), y â‰  0 âˆ§ (inner x y) = (0 : â„) := 
(A B : Set X) (hA : IsClosed A) (hB : IsClosed B) (hAB : Disjoint A B) : Separated A B := 
(k : â„•) (E : Set (EuclideanSpace â„ (Fin k)))(hE : E.Nonempty âˆ§ Â¬ Set.Countable E)(hP : P = {x | âˆ€ U âˆˆ ğ“ x, Â¬ Set.Countable (U âˆ© E)}) : (h : âˆƒ C : Set (EuclideanSpace â„ (Fin k)), Set.Countable C âˆ§ E \ P âŠ† C) := 
(U : Set â„) (hU : IsOpen U) : âˆƒ (S : Set (Set â„)), (âˆ€ s âˆˆ S, âˆƒ a b : â„, s = Ioo a b) âˆ§ Set.Countable S âˆ§ (âˆ€ sâ‚ sâ‚‚ âˆˆ S, sâ‚ â‰  sâ‚‚ â†’ Disjoint sâ‚ sâ‚‚) := 
 : Tendsto (Î» n => (sqrt (n^2 + n) - n)) atTop (ğ“ (1/2)) := 
(âˆ€ (a b : â„• â†’ â„), true)âˆ€ (a b : â„• â†’ â„), limsup (Î» n, a n + b n) â‰¤ limsup a + limsup b : Â¬(limsup a = âŠ¤ âˆ§ limsup b = âŠ¤) := 
(h2 : âˆƒ y, (Tendsto (Î» n => (âˆ‘ i in (range n), a i)) atTop (ğ“ y)))(a_n : â„) (h_an : 0 â‰¤ a_n) : (h_converges : âˆƒ y, Tendsto (Î» n => (âˆ‘ i in (range n), a i)) atTop (ğ“ y)) â†’
âˆƒ z, Tendsto (Î» n => (âˆ‘ i in (range n), (sqrt (a i)) / n)) atTop (ğ“ z) := 
âˆ€ (a b : â„• â†’ â„), Summable a â†’ Summable b â†’ Summable (Î» n, âˆ‘ i in finset.range (n+1), a i * b (n - i)) : âˆ€ (n : â„•), Summable (Î» n, abs (a n)) := 
(E : â„• â†’ Set X) (hE : âˆ€ n, IsClosed (E n) âˆ§ Nonempty (E n) âˆ§ Bounded (E n))(hEn : âˆ€ n, E n âŠ‡ E (n + 1))(lim : tendsto (Î» n, diam (E n)) at_top (ğ“ 0)) : âˆƒ! x, x âˆˆ â‹‚ n, E n := 
(f : â„ â†’ â„)âˆ€ x : â„, tendsto (Î» h, f (x + h) - f (x - h)) (ğ“ 0) (ğ“ 0) : {f : â„ â†’ â„} := 
{Î± : Type} [MetricSpace Î±] (f : Î± â†’ â„) (hâ‚ : Continuous f)Zf := {p âˆˆ X | f p = 0} : is_closed Zf := 
{X : Type} [MetricSpace X] {Y : Type} [MetricSpace Y] (f g : X â†’ Y) (hf : Continuous f) (hg : Continuous g)(E : Set X) (hE : Dense E)(h : âˆ€ p âˆˆ P, g p = f p) : âˆ€ p âˆˆ X, g p = f p := 
âˆƒ E : Set â„, E âŠ† Set.univ(f : â„ â†’ â„) (E : Set â„) (h : ContinuousOn f E) : Â¬âˆƒ (g : â„ â†’ â„), Continuous g âˆ§ âˆ€ x âˆˆ E, f x = g x := 
(f : â„ â†’ â„) (E : Set â„) (hâ‚ : IsBounded E) (hâ‚‚ : UniformContinuousOn f E) : Bornology.IsBounded (Set.image f E) := 
{Î± : Type} [MetricSpace Î±] {Î² : Type} [MetricSpace Î²] (f : Î± â†’ Î²) (hâ‚ : UniformContinuous f)âˆ€ (x : â„• â†’ X) (hx : CauchySeq x) : âˆ€ Îµ > 0, âˆƒ N, âˆ€ m n â‰¥ N, dist (f (x m)) (f (x n)) < Îµ := 
âˆ€ (f : â„ â†’ â„) (hf : Continuous f) (ho : IsOpenMap f) : âˆ€ (f : â„ â†’ â„) (hf : Continuous f) (ho : IsOpenMap f), Monotone f := 
(K F : Set X) [MetricSpace X] (h_disjoint : Disjoint K F)(hKc : IsCompact K)(F : Set X) (hF : IsClosed F) : (âˆƒ Î´ > 0, âˆ€ p q, p âˆˆ K â†’ q âˆˆ F â†’ d p q > Î´) := 
âˆ€ x : â„, f x(h : âˆ€ x y : â„, |f x - f y| â‰¤ (x - y) ^ 2) : âˆ€ a b : â„, f a = f b := 
{g : â„ â†’ â„}(hg' : âˆ€ x, |g' x| â‰¤ M)let Îµ > 0 in Î» x => x + Îµ * g x : theorem f_one_to_one_if_epsilon_small (hÎµ : Îµ > 0) (hÎµ_small : Îµ < Î´) : function.injective f := := 
{f : â„ â†’ â„} (hf : DifferentiableOn â„ f (Set.Ioi 0))(hf3 : Tendsto (fun x => f' x) atTop (nhds 0))Î» x => f (x + 1) - f x : Tendsto (Î» x => g x) atTop (nhds 0) := 
(hf : âˆ€ x, DifferentiableAt â„ f x) (hg : âˆ€ x, DifferentiableAt â„ g x)âˆ€ x, deriv g x â‰  0(hfg : âˆ€ x, f x = 0 âˆ§ g x = 0) : âˆ€ x, Tendsto (Î» t, f t / g t) (ğ“ x) (ğ“ (deriv f x / deriv g x)) := 
{f : â„ â†’ â„} (hf' : DifferentiableOn â„ f (Set.Icc (-1) 1)) (hf'' : DifferentiableOn â„ (deriv f) (Set.Icc (-1) 1)) (hf''' : DifferentiableOn â„ (deriv (deriv f)) (Set.Icc (-1) 1))(hf4 : f (-1) = 0)(hf3 : f 0 = 0)(hf5 : f 1 = 1)(hf'0 : deriv f 0 = 0) : âˆƒ x âˆˆ Set.Ioo (-1 : â„) 1, deriv (deriv (deriv f)) x â‰¥ 3 := 
{G : Type*} [Group G] [Fintype G] [Even (Fintype.card G)] : âˆƒ (a : G), a â‰  1 âˆ§ a = aâ»Â¹ := 
{G : Type*} [Group G] [Fintype G](a : G) : âˆƒ (n : â„•), 0 < n âˆ§ a ^ n = 1 := 
{G : Type*} [Mul G] [Group G](h : âˆƒ (i : â„¤), âˆ€ (a b : G), (a * b) ^ i = a ^ i * b ^ i âˆ§ (a * b) ^ (i + 1) = a ^ (i + 1) * b ^ (i + 1) âˆ§ (a * b) ^ (i + 2) = a ^ (i + 2) * b ^ (i + 2)) : CommGroup G := 
{G : Type*} [Group G](h : âˆƒ n : â„¤, n > 1 âˆ§ âˆ€ (a b : G), (a * b) ^ n = a ^ n * b ^ n) : (h : âˆ€ (a b : G), (a * b * aâ»Â¹ * bâ»Â¹) ^ (n * (n - 1)) = 1) := 
{G : Type*} [Group G] (H : Subgroup G) (h : H â‰  âŠ¥) (h' : H â‰  âŠ¤) : IsCyclic G âˆ§ Fintype.card G = p := 
{G : Type*} [Group G]âˆ€ (H : Subgroup G), H.Normal(a b : G) : âˆƒ (j : â„¤), b * a = a ^ j * b := 
{G : Type*} [CommGroup G] [Fintype G] (p : â„•) [hp : Fact p.Prime] (n m : â„•) (hG : Fintype.card G = p^n * m) (hpm : p âˆ£ m â†’ False){H : Subgroup G} [Fintype H] (hH : card H = p^n) : H.Characteristic := 
(G : Type*) [Group G] [Fintype G] (hG : card G = 9) : CommGroup G := 
{G : Type*} [Group G] [Fintype G]{Ï† : G â†’ G} (hÏ† : IsGroupHom Ï†) (hbij : Bijective Ï†)(hÏ†_inv : âˆƒ S : Finset G, S.card > 3 * (Fintype.card G) / 4 âˆ§ âˆ€ x âˆˆ S, Ï† x = xâ»Â¹) : âˆ€ y : G, Ï† y = yâ»Â¹ âˆ§ CommGroup G := 
{Ï† : G â†’ G'} (hÏ† : Function.Surjective Ï† âˆ§ âˆ€ x y : G, Ï† (x * y) = Ï† x * Ï† y)(hN : N.Normal) : âˆ€ x y : G, Ï† x * Ï† y = Ï† (x * y) âˆ§ Function.Surjective Ï† âˆ§ N.Normal â†’ (âˆ€ n : N, âˆ€ g' : G', âˆƒ n' : N, Ï† n' = g' * Ï† n * g'â»Â¹) := 
[p > q] [Fact (p.Prime)] [Fact (q.Prime)](hq : q âˆ£ p - 1){G H : Type*} [Fintype G] [Fintype H] [Group G] [Group H] (hG : card G = p * q) (hH : card H = p * q) (hG1 : IsEmpty (CommGroup G)) (hH1 : IsEmpty (CommGroup H)) : G â‰ƒ* H := 
(A : NormalSubgroup G)(b : G) (hb : orderOf b = p) [Fact (Nat.Prime p)](b âˆ‰ A) : show : A âŠ“ subgroup.closure {b} = âŠ¥ := 
(hP : P.Normal){P : Sylow p G}{p : â„•} (hp : Nat.Prime p){G : Type*} [Fintype G] [Group G] : âˆ€ (Ï† : G â‰ƒ* G), Ï† '' P = P := 
(Ïƒ Ï„ : Equiv.Perm Î±)âˆ€ x, Ïƒ x â‰  Ï„ x(hÏƒÏ„ : Ïƒ âˆ˜ Ï„ = Equiv.refl Î±) : Ïƒ = Equiv.refl Î± âˆ§ Ï„ = Equiv.refl Î± := 
def T : group (matrix (fin 2) (fin 2) (zmod 2)) :=
{ carrier := {A | det A â‰  0},
  one_mem' := by simp,
  mul_mem' := by simp [det_mul],
  inv_mem' := by simp [det_inv] } : T â‰ƒ* Equiv.Perm (Fin 3) := 
{a : R} (ha : a^2 = 0){a : R} (ha : a^2 = 0) â†’ : âˆ€ a x : R, a * x + x * a âˆˆ centralizer {a} := 
{R : Type*} [CommRing R]a : RL : R â†’ set R := Î» a, {x | x * a = 0} : Ideal R (L a) := 
âˆƒ (s : Finset â„•), s.card = (p - 1) / 2 âˆ§ âˆ€ x âˆˆ s, âˆƒ y, y^2 â‰¡ x [MOD p]âˆƒ (s : Finset â„•), s.card = (p - 1) / 2 âˆ§ âˆ€ x âˆˆ s, Â¬ âˆƒ y, y^2 â‰¡ x [MOD p]âˆƒ (sâ‚ sâ‚‚ : Finset â„•), sâ‚.card = (p - 1) / 2 âˆ§ sâ‚‚.card = (p - 1) / 2 âˆ§
(sâ‚ âˆª sâ‚‚ = Finset.range (p - 1) âˆ§ sâ‚ âˆ© sâ‚‚ = âˆ…) âˆ§
(âˆ€ x âˆˆ sâ‚, âˆƒ y, y^2 â‰¡ x [MOD p]) âˆ§
(âˆ€ x âˆˆ sâ‚‚, Â¬ âˆƒ y, y^2 â‰¡ x [MOD p]){p : â„•} (hp : Nat.Prime p) : {p : â„•} (hp : Nat.Prime p) := 
{p : â„•} (hp : p = 7)X ^ 3 - 2 : Polynomial Fx ^ 3 + 2 : Polynomial FIrreducible (X ^ 3 - 2 : Polynomial (ZMod 7)) âˆ§ Irreducible (X ^ 3 + 2 : Polynomial (ZMod 7)) : âˆƒ (e : (Polynomial (ZMod 7) â§¸ span ({X ^ 3 - 2} : Set (Polynomial (ZMod 7)))) â‰ƒ+* (Polynomial (ZMod 7) â§¸ span ({X ^ 3 + 2} : Set (Polynomial (ZMod 7)))), true := 
2 + 3 * X + X ^ 3 : Polynomial FIrreducible (2 + 3 * X + X ^ 3 : Polynomial Q) : Irreducible (2 + 3 * X + X ^ 3 : Polynomial Q) := 
{p : â„•} (hp : p â‰  0)(h : (a + b) ^ m = a ^ m + b ^ m)(m : â„•) (h : m = p ^ n)âˆ€ a b : F, : (n : â„•) := 
(a : K)IsAlgebraic F (a ^ 2)(a : K) (h : IsAlgebraic F (a ^ 2)) : IsAlgebraic F a := 
(a : C){p : â„•}(hp : p a = 0) : IsAlgebraic â„š a âˆ§ degree (minpoly â„š a) â‰¤ 80 := 
(char_p F p)(m : â„•) (h : m = p ^ n) : âˆ€ i j, i â‰  j â†’ x ^ i â‰  x ^ j := 
{U : Set M}{U : Set M}(hU : âˆ€ (x : X), x âˆˆ U â†” âˆ€ (y : X), y âˆˆ closure (M \ U) â†’ y â‰  x)(hU : IsOpen U) : (h : âˆ€ (x : X), x âˆˆ U â†’ x âˆ‰ closure (M \ U)) := 
âˆ€ (s : set â„•) : âˆ€ (s : set â„•), is_clopen s := 
(hAc : IsCompact A) (hBc : IsCompact B)(hAB : Disjoint A B)(hA : A.Nonempty) (hB : B.Nonempty)(hSub : âˆ€ S, S âŠ† M) : (ha0 : a0 âˆˆ A) (hb0 : b0 âˆˆ B) (h : âˆ€ a âˆˆ A, âˆ€ b âˆˆ B, d a0 b0 â‰¤ d a b) := 
âˆ€ (C : â„• â†’ Set X), (âˆ€ n, IsCompact (C n)) âˆ§ (âˆ€ n, C n â‰  âˆ…) âˆ§ (âˆ€ n, C (n + 1) âŠ† C n) â†’ âˆƒ x, âˆ€ n, x âˆˆ C nNonempty X : âˆ€ x, x âˆˆ P â†’ âˆƒ y, y âˆˆ P âˆ§ y â‰  x := 
(f : â„ â†’ â„)(h : âˆ€ t x : â„, |f t - f x| â‰¤ |t - x|^2) : âˆ€ a b : â„, f a = f b := 
(f : â„• â†’ â„) (h : f = Î» (k : â„•) => (1 : â„) / (k * (log k) ^ p))âˆƒ l, Tendsto f atTop (ğ“ l) : (p : â„) (hp : 1 < p) := 
(hÎ¼ : Continuous Î¼) (hÎ¼_strict : StrictMono Î¼) (hÎ¼_modulus : âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ s, 0 < s < Î´ â†’ Î¼ s < Îµ){f : â„ â†’ â„} {a b : â„} (hab : a â‰¤ b) {Î¼ : â„ â†’ â„} (hmodulus : âˆ€ s t âˆˆ set.Icc a b, |f s - f t| â‰¤ Î¼ (|s - t|)) : theorem uniformly_continuous_iff_modulus_of_continuity {f : â„ â†’ â„} :
  UniformContinuous f â†” âˆƒ Î¼ : â„ â†’ â„, (Continuous Î¼) âˆ§ (StrictMono Î¼) âˆ§ (âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ s, 0 < s < Î´ â†’ Î¼ s < Îµ) âˆ§ (âˆ€ s t, |f s - f t| â‰¤ Î¼ (|s - t|)) := := 
{G : Type*} [Group G] (a b : G) : IsConjugate G (a * b) (b * a){G : Type*} [Group G] : (a * b) (b * a) := 
âˆ€ (F K : Type*) [field F] [field K] (f : F â†’+* K), âˆ€ x y : F, f (x * y) = f x * f y{F K : Type*} [field F] [field K]Injective f : âˆ€ (F K : Type*) [field F] [field K] (f : F â†’+* K), Function.Injective f := 
{F V : Type*} [Infinite F] [Field F] [AddCommGroup V] [Module F V]{F : Type*} [Infinite F] [Field F]{Î¹ : Type*} [Fintype Î¹] {u : Î¹ â†’ Submodule F V} (hu : âˆ€ i : Î¹, u i â‰  âŠ¤) (â‹ƒ i : Î¹, (u i : Set V)) â‰  âŠ¤{Î¹ : Type*} [Fintype Î¹] {u : Î¹ â†’ Submodule F V} (hu : âˆ€ i : Î¹, u i â‰  âŠ¤) : theorem not_union_of_finitely_many_proper_subspaces {Î¹ : Type*} [Fintype Î¹] {u : Î¹ â†’ Submodule F V} (hu : âˆ€ i : Î¹, u i â‰  âŠ¤) : (â‹ƒ i : Î¹, (u i : Set V)) â‰  âŠ¤ :=
begin
  -- proof goes here
end := 
{G : Type*} [Group G] [Fintype G] {p q : â„•} (hp : Prime p) (hq : Prime q) (hG : card G = p * q) : IsSimpleGroup G â†’ false := 
{G : Type*} [Fintype G] [Group G] (hG : card G = 224) : {G : Type*} [Fintype G] [Group G] (hG : card G = 224) : Â¬SimpleGroup G := 
IsNilpotent x â†” âˆƒ n : â„•, x^n = 0(h : IsNilpotent x) : {u : R} (hu : is_unit (1 + u)) := 
{I : Ideal â„¤[i]} (hI : I â‰  âŠ¥) : {n : â„¤} (hn : n â‰  0) := 
{R : Type*} [CommRing R] (I J : Ideal R)I âŠ” J = âŠ¤ : I * J = I âŠ“ J := 
(a b : â„¤)(a b : â„¤[i]) (h : a âˆ£ b) : (h : a âˆ£ b) := 
Irreducible ((Polynomial.X)^2 + Polynomial.X + 1 : Polynomial (ZMod 2))ZMod 2 : Irreducible (X ^ 2 + X + 1 : Polynomial F) := 
Irreducible (X^3 - 9 : Polynomial (ZMod 31)) : Irreducible (X^3 - 9 : Polynomial (ZMod 31)) := 
 : Infinite {p : Nat.Primes // p â‰¡ -1 [ZMOD 4]} := 
{K : Type*} [Field K] [Fintype K] : âˆ (x : K) in (finset.univ \ {0}), x = -1 := 
(-1 + complex.I * real.sqrt 3) / 2 : {x : â„‚} (h : x^3 = 1) := 
{a : ğ•œ}{v : V}(hav : a * v = 0)(ha_or_hv : a = 0 âˆ¨ v = 0)âˆ€ (a : ğ•œ) (v : V), a â€¢ v = 0 â†’ a = 0 âˆ¨ v = 0[ğ•œ : field] : {ğ•œ V : Type*} [Field ğ•œ] [AddCommGroup V] [Module ğ•œ V] := 
âˆƒ U : Set (â„ Ã— â„), U â‰  âˆ…âˆ€ (c : â„) (u : â„ Ã— â„), u âˆˆ U â†’ c â€¢ u âˆˆ U : âˆ€ U' : Submodule â„ (â„ Ã— â„), U â‰  â†‘U' := 
(uâ‚ uâ‚‚ : Submodule F V)âˆƒ U : Submodule F V, (uâ‚ âŠ” uâ‚‚).carrier = â†‘U(uâ‚ uâ‚‚ : Submodule F V) (h : uâ‚ â‰¤ uâ‚‚ âˆ¨ uâ‚‚ â‰¤ uâ‚) : (uâ‚ uâ‚‚ : Submodule F V) (h : uâ‚ âŠ” uâ‚‚ = uâ‚ âˆ¨ uâ‚ âŠ” uâ‚‚ = uâ‚‚) := 
{V : Type*} [FiniteDimensional â„‚ V](T : V â†’â‚—[F] W) : âˆƒ (U : Submodule K V), U âŠ“ T.ker = âŠ¥ âˆ§ T.range = âŠ¤.map U.subtype := 
{T : End F V}{U : â„• â†’ Submodule K V // âˆ€ i, U i â‰¤ T (U i)} : Submodule.map T (â¨† i, U i) = â¨† i, U i := 
(S T : V â†’â‚—[F] V) : (S * T).eigenvalues = (T * S).eigenvalues := 
{T : End F V}âˆ€ (U : Submodule F V), finite_dimensional.finrank F U = finite_dimensional.finrank F V - 1 â†’ âˆ€ (v âˆˆ U), T v âˆˆ U(hT : âˆ€ (U : Submodule F V), finite_dimensional.finrank F U = finite_dimensional.finrank F V - 1 â†’ âˆ€ (v âˆˆ U), T v âˆˆ U) : âˆƒ c : F, T = c â€¢ LinearMap.id := 
{V : Type*} [AddCommGroup V] [Module â„ V](h : âˆ€ c : F, eigenspace T c = âŠ¥)âˆ€ (U : Submodule â„ V), (âˆ€ v âˆˆ U, T v âˆˆ U) : [FiniteDimensional F V] (hT : even (finrank F V)) := 
âˆ€ (n : â„•) (a b : â„• â†’ â„), (âˆ‘ j in finset.range n, a j * b j) ^ 2 â‰¤ (âˆ‘ j in finset.range n, j * (a j) ^ 2) * (âˆ‘ j in finset.range n, (b j) ^ 2 / j) : theorem sum_inequality (n : â„•) (a b : â„• â†’ â„) :
  (âˆ‘ j in finset.range n, a j * b j) ^ 2 â‰¤
  (âˆ‘ j in finset.range n, j * (a j) ^ 2) * (âˆ‘ j in finset.range n, (b j) ^ 2 / j) := := 
{m : â„•} (e : Fin m â†’ V) (h_orthonormal : OrthonormalBasis (Fin m) K V e)(v : V) â†’ : â€–vâ€–^2 = (âˆ‘ i, â€–âŸªv, e iâŸ«_â„‚â€–^2) â†” v âˆˆ Submodule.span K (Set.range e) := 
(hT : 2 â‰¤ finrank F V){T : End â„‚ V | T * adjoint T = adjoint T * T}Â¬ submodule â„‚ (End â„‚ V) {T : End â„‚ V | T * adjoint T = adjoint T * T} : {K V : Type*} [RCLike K] [NormedAddCommGroup V] [InnerProductSpace K V] := 
{T : V â†’ V} [NormalOperator â„‚ V](hT : IsSelfAdjoint T)(h2 : âˆ€ Î» âˆˆ T.Eigenvalues, Î» âˆˆ â„) : âˆ€ {T : V â†’ V} [NormalOperator â„‚ V], IsSelfAdjoint T â†” âˆ€ Î» âˆˆ T.Eigenvalues, Î» âˆˆ â„ := 
{V : Type*} [NormedAddCommGroup V] [InnerProductSpace â„‚ V]âˆ€ (T : End â„‚ V), T * adjoint T = adjoint T * Tâˆƒ (x : â„), x^2 = _{V : Type*} [NormedAddCommGroup V] [InnerProductSpace â„‚ V] : âˆ€ (T : End â„‚ V) (hT : T * adjoint T = adjoint T * T), âˆƒ (S : End â„‚ V), S * S = T := 
(h : âˆ€ a b : â„¤, a â¬ b = a - b) : Â¬CommRing (â„¤, â¬) := 
âˆ€ (a b c : â„¤), (a*b)*c â‰¡ a*(b*c) [ZMOD n] : (n : â„¤) := 
(h : âˆ€ (n : â„•) (a : fin n â†’ G), (âˆ i in finset.range n, a i)â»Â¹ = âˆ i in finset.range n.reverse, (a i)â»Â¹)(a : fin n â†’ G) : âˆ€ (n : â„•) (a : fin n â†’ G), (âˆ i in finset.range n, a i)â»Â¹ = âˆ i in finset.range n.reverse, (a i)â»Â¹ := 
{G : Type*} [Group G] (x : G)âˆƒ (n : â„•), |x| = n : xâ»Â¹ = x^(n - 1) := 
{G : Type*} [Group G] (x : G) : orderOf x = orderOf xâ»Â¹ := 
(a b : G) : (h : âˆ€ (a b : G), |a * b| = |b * a|) := 
variables {A B : Type*} [CommGroup A] [CommGroup B]
example : CommGroup (A Ã— B) â†” CommGroup A âˆ§ CommGroup B :=
âŸ¨Î» h, âŸ¨by apply_instance, by apply_instanceâŸ©, Î» âŸ¨hA, hBâŸ©, by apply_instanceâŸ©variables {A B : Type*} [CommGroup A] [CommGroup B]variables {A B : Type*} [CommGroup A] [CommGroup B]
example : CommGroup (A Ã— B) :=
by apply_instanceâˆ€ a b : A, a * b = b * a âˆ§ âˆ€ a b : B, a * b = b * avariables {A B : Type*} [Group A] [Group B]

example : CommGroup (A Ã— B) â†” CommGroup A âˆ§ CommGroup B :=
âŸ¨Î» h, âŸ¨by apply_instance, by apply_instanceâŸ©, Î» âŸ¨hA, hBâŸ©, by apply_instanceâŸ©(A B : Set X){A : Type*} [Group A] : {B : Type*} [Mul B] [Group B] := 
(Î© : Set â„‚) (h : Î© = {1, 2, 3, ...}) : (SÎ© : Group) (h : Infinite SÎ©) := 
{G : Type*} [Group G] [Fintype G]âˆƒ Ïƒ : Aut GÏƒ g = g â†” g = 1(Ïƒ : Aut G) (hÏƒ : Ïƒ ^ 2 = 1) : CommGroup G := 
(H : AddSubgroup â„š)âˆ€ x âˆˆ H, x â‰  0 â†’ 1 / x âˆˆ H : H = âŠ¥ âˆ¨ H = âŠ¤ := 
{G : Type*} [Group G] (M : Subgroup G) : Prop :=
M â‰  âŠ¤ âˆ§ âˆ€ (H : Subgroup G), M â‰¤ H â†’ H = M âˆ¨ H = âŠ¤{G : Type*} [Group G] [Fintype G] (H : Subgroup G) (H â‰  âŠ¤) : âˆƒ (M : Subgroup G), M â‰  âŠ¤ âˆ§ âˆ€ (K : Subgroup G), M â‰¤ K â†’ K = M âˆ¨ K = âŠ¤ âˆ§ H â‰¤ M := 
{R G : Type*} [Group G] [IsCyclic G] [Fintype G] (x : G) (hx : G = Subgroup.closure {x}) (hn : Fintype.card G = n) (hn_pos : 1 â‰¤ n){G : Type*} [Group G] (H : Subgroup G) [IsMaximalSubgroup H](p : â„•) [Fact p.Prime] (hp : p âˆ£ n) (H : Subgroup G) (hx_p : H = Subgroup.closure {x ^ p}) : show (if ... then ...) â†” ... := 
{G : Type*} [Group G] (H K : NormalSubgroup G) : (N : NormalSubgroup G) (hN : N = H âŠ“ K) := 
{G : Type*} [Group G] (H K : Subgroup G) [Fintype H] [Fintype K](Coprime (card H) (card K)) : {G : Type*} [Group G] {H K : Subgroup G} (hHK : H âŠ“ K = âŠ¥) := 
{p : â„•} (hp : Nat.Prime p)(a : â„¤) : âˆ€ a : â„¤, Nat.Prime p â†’ a^p â‰¡ a [MOD p] := 
{H : Subgroup G} [H.Normal] (hH : card (G â§¸ H) = p) : âˆ€ K : Subgroup G, K â‰¤ H âˆ¨ (G = H âŠ” K âˆ§ K.relindex (K âŠ“ H) = p) := 
Fintype (CommGroup G){G : Type*} [Fintype G] [Group G] {n : â„•} (hn : n âˆ£ card G) {H : Subgroup G} [Fintype H] (hH : card H = n)begin
  apply cauchy_theorem,
  induction,
end : (hG2 : âˆ€ n : â„•, n âˆ£ card G â†’
  âˆƒ (H : Subgroup G) (fH : Fintype H), @card H fH = n) := 
(N : QuotientGroup G) [IsSolvable G] : IsSolvable K := 
index H = nâˆƒ (K : Subgroup G), K.Normal âˆ§ K â‰¤ H âˆ§ index G K â‰¤ n!{G : Type*} [Fintype G] [Group G] : (n : â„•) := 
{p : â„•} (hp : Nat.Prime p){G : Type*} [Mul G] [Group G] {p : â„•} (hp : Nat.Prime p) {Î± : â„•} [Fintype G] (hG : Fintype.card G = p ^ Î±){Î± : â„•} (hÎ± : Î± > 0) : âˆ€ {H : Subgroup G} [Fintype H], Fintype.card (G â§¸ H) = p â†’ H.Normal := 
{G : Type*} [CommGroup G] [Fintype G] (hpq : Fintype.card G = p * q) (hp : Nat.Prime p) (hq : Nat.Prime q) (hpq_distinct : p â‰  q) : IsCyclic G := 
 : âˆƒ (N : Subgroup G), N.Normal âˆ§ Â¬N.Characteristic := 
{G : Type*} [Group G]{G : Type*} [Group G] (H K : Subgroup G) (hHK : H â‰¤ K)H.Characteristic_in KK.Normal_in G : H.Normal := 
(G : Type*) [Group G] [Fintype G] (hG : card G = 56) : âˆƒ (p : â„•) (P : Sylow p G), P.Normal := 
{G : Type*} [Group G] [Fintype G] (hG : card G = 351) : âˆƒ (p : â„•) (P : Sylow p G), P.Normal := 
(hG : card G = 105)(hG : card G = 105) â†’ (âˆƒ Nâ‚… : Sylow 5 G, Nâ‚….Normal) âˆ§ (âˆƒ Nâ‚‡ : Sylow 7 G, Nâ‚‡.Normal) : {G : Type*} [Fintype G] [Group G] := 
(hG : card G = 6545)Â¬ IsSimpleGroup GÂ¬ IsSimpleGroup GÂ¬ IsSimpleGroup G : {G : Type*} [Fintype G] [Group G] := 
(hG : card G = 2907)Â¬ IsSimpleGroup G : Â¬ IsSimpleGroup G := 
(hG : card G = 462)Â¬ IsSimpleGroup G{G : Type*} [Fintype G] [Group G] : Â¬ IsSimpleGroup G := 
{P : Sylow p G} (hP : P.normal){G : Type*} [Group G] (H : Subgroup G)âˆ€ (Q : Sylow p H), P âŠ“ H = Q{G : Type*} [Fintype G] [Group G]H : {p : â„•} (hp : Nat.Prime p) := 
is_unit u : âˆ€ (u : R), u âˆˆ U â†’ -u âˆˆ U := 
âˆ€ (R : Type*) [Ring R] (F : Type*) [Field F] [Algebra R F], âˆ€ (S : Subring F), (1 : F) âˆˆ S : theorem subring_of_field_is_domain {F : Type*} [Field F] (S : Subring F) (hS : (1 : F) âˆˆ S) : IsDomain S :=
begin
  haveI : Nontrivial S := Subring.nontrivial_of_one_mem S hS,
  exact Subring.is_domain_of_field S,
end := 
variables {R : Type*} [comm_ring R] (a : â„• â†’ R) (n : â„•)
def p : polynomial R := âˆ‘ i in finset.range (n + 1), a i * X^i : theorem zero_divisor_iff_exists_nonzero_b (p : polynomial R) :
  (âˆƒ q : polynomial R, q â‰  0 âˆ§ p * q = 0) â†” âˆƒ b : R, b â‰  0 âˆ§ b â€¢ p = 0 := := 
{Ï† : R â†’+* S} (hÏ† : Function.Surjective Ï†) : map_center_subset_center Ï† := 
{R : Type*} [CommRing R] [Nontrivial R]IsNilpotent ab : R : (hâ‚„ : IsUnit (1 - a * b)) := 
{R : Type*} [Ring R] [IsDomain R]âˆ€ {a b : R} (ha : a â‰  0) (hb : b â‰  0), âˆƒ (gcd : R) (r s : R), gcd = r * a + s * bâˆ€ (a : â„• â†’ R) (h : âˆ€ i, a (i + 1) âˆ£ a i) (hnz : âˆ€ i, a i â‰  0), âˆƒ N : â„•, âˆ€ n â‰¥ N, âˆƒ u : R, IsUnit u âˆ§ a n = u * a N : IsPrincipalIdealRing R := 
def R (n : â„¤) [squarefree n] (h : n > 3) : Type := â„¤[âˆš(-n)] : Irreducible (2 : R) âˆ§ Irreducible (âˆš(-n) : R) âˆ§ Irreducible (1 + âˆš(-n) : R) := 
[Fact (q.Prime)]{q : â„•} (h0 : q â‰¡ 3 [ZMOD 4])(hR : R = (GaussianInt â§¸ span ({âŸ¨q, 0âŸ©} : Set GaussianInt))) : IsField R âˆ§ âˆƒ finR : Fintype R, @card R finR = q^2 := 
Polynomial â„¤ â§¸ Ideal.span ({X 1 * X 2, X 3 * X 4, X 5 * X 6} : Set (Polynomial â„¤)) : let R := Polynomial â„¤ â§¸ Ideal.span ({X 1 * X 2, X 3 * X 4, X 5 * X 6} : Set (Polynomial â„¤))
example : âˆƒ (P : Ideal R), P.is_prime âˆ§ âˆ€ (Q : Ideal R), Q.is_prime â†’ P â‰¤ Q â†’ P = Q :=
begin
  -- proof goes here
end := 
 : Irreducible (X^4 - 4*X^3 + 6 : Polynomial â„¤) := 
1 + 2 * X + 6 * X ^ 2 + 4 * X ^ 3 + X ^ 4 : Polynomial FIrreducible (âˆ‘ n in (f.support \ {0}), (f.coeff n : Polynomial â„¤) * X ^ (n-1) : Polynomial â„¤) : Irreducible (X^4 + 4*X^3 + 6*X^2 + 2*X + 1 : Polynomial â„¤) := 
(x : â„)Irreducible (x ^ 2 - sqrt 2 : Polynomial (â„¤[âˆš2])) : assume (hUFD : UniqueFactorizationDomain (â„¤[âˆš2])) := 
variables (n : â„•) (h : n > 0)
example : (â„^n) â‰ƒâ‚—[â„š] â„ := sorry : variables (n : â„•) (h : n > 0)
example : (â„^n) â‰ƒâ‚—[â„š] â„ := sorry := 
{X : Type*} (ğ’¯_âˆ : Set (Set X)) := {U | X \ U = âˆ… âˆ¨ X \ U = X âˆ¨ âˆƒ (s : Set X), X \ U = s âˆ§ s.infinite} : Â¬TopologicalSpace X := 
(X I : Type*) (T : I â†’ Set (Set X)) (h : âˆ€ i, is_topology X (T i)) : Â¬ is_topology X (â‹ƒ i : I, T i) := 
variables (X I : Type*) (T : I â†’ Set (Set X)) (h : âˆ€ i, is_topology X (T i)) : âˆƒ! T', is_topology X T' âˆ§ (âˆ€ i, T' âŠ† T i) âˆ§ âˆ€ T'', is_topology X T'' â†’ (âˆ€ i, T'' âŠ† T i) â†’ T' âŠ† T'' := 
{X : Type*} (A : Set (Set X)) (hA : IsTopologicalSubbasis A)generateFrom A : = generateFrom (sInter {T | is_topology X T âˆ§ A âŠ† T}) := 
{S : Set â„ | âˆƒ a b : â„š, a < b âˆ§ S = Ico â†‘a â†‘b} : is_basis (Î» S, âˆƒ a b : â„, a < b âˆ§ S = Ioo a b) (ğ“¤ â„) := 
{Y : Submodule K X}(A : Set Y) : theorem subspace_topology_inheritance {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] (A : Set X) (h : A âŠ† Y) :
  SubspaceTopology A Y = SubspaceTopology A X := := 
generateFrom {S : Set (â„ Ã— â„) | âˆƒ a b c d : â„š, a < b âˆ§ c < d âˆ§ S = Ico (â†‘a, â†‘c) (â†‘b, â†‘d)} : is_basis (ğ“ (0 : â„ Ã— â„)) := 
{Y : Type*} [LinearOrder Y] [OrderTopology Y]{f g : X â†’ Y} (hf : Continuous f) (hg : Continuous g)is_closed {x | f x â‰¤ g x} : {X : Type*} [TopologicalSpace X] := 
{A : Set X}(f : A â†’ Y){f : A â†’ Y} (hf : Continuous f){Y : Type*} [T2Space Y](âˆƒ g : Closure A â†’ Y, Continuous g){A : Set X} : (âˆ€ gâ‚ gâ‚‚ : Closure A â†’ Y, Continuous gâ‚ â†’ Continuous gâ‚‚ â†’ (âˆ€ x âˆˆ A, gâ‚ x = f x) â†’ (âˆ€ x âˆˆ A, gâ‚‚ x = f x) â†’ gâ‚ = gâ‚‚) := 
{R : Type*} [LinearOrder R] [OrderTopology R] (R Ã— R) [OrderTopology (R Ã— R)] : {R : Type*} [LinearOrder R] [OrderTopology R] [MetrizableSpace (R Ã— R)] := 
(f : â„• â†’ I â†’ â„ ) (h : âˆ€ x n, f n x = x ^ n) : (hh : Â¬ TendstoUniformly f fâ‚€ atTop) := 
{p : X â†’ Y} (hp : Continuous p)(p : X â†’ Y){f : Y â†’ X} (hf : Continuous f) (hâ‚‚ : âˆ€ y : Y, p (f y) = y) : QuotientMap p := 
open_map p(U A : Set X) (hA : IsOpen A)(q : A â†’ p(A)) (hq : OpenMap q) : {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] := 
{X : Type*} [TopologicalSpace X] {A : Î¹ â†’ Set X} (hA : âˆ€ Î±, IsConnected (A Î±))(A : Set X) (hA : IsConnected A)(hAÎ± : âˆ€ Î±, A âˆ© A Î± â‰  âˆ…) : IsConnected (A âˆª â‹ƒ Î±, A Î±) := 
{A : Set X}[TopologicalSpace X] [ConnectedSpace C] [Subspace C X](hCA : C âˆ© A â‰  âˆ…) (hCXA : C âˆ© (X \ A) â‰  âˆ…) : (hCBA : C âˆ© (Closure A \ Interior A) â‰  âˆ…) := 
(p : X â†’ Y) (hâ‚ : quotient_map p)IsConnected (p â»Â¹' {y})(hY : IsConnected Y) : hX : IsConnected X := 
{f : X â†’ X} (hf : Continuous f){X : Set â„} (hX : X = Set.Icc 0 1) : âˆƒ x, f x = x := 
{G : Type*} [TopologicalGroup G]{G : Type*} [TopologicalGroup G] (e : G) (C : set G) [ConnectedComponent C e] : C.Normal := 
(p : X â†’ Y)(hf : Continuous f) (hfs : Function.Surjective f) (hf_closed : IsClosedMap f)(hâ‚‚ : âˆ€ y âˆˆ Y, IsCompact (p â»Â¹' {y})){X : Type} [TopologicalSpace X] {Y : Type} [TopologicalSpace Y] 
(p : X â†’ Y) (hp_cont : Continuous p) (hp_surj : Function.Surjective p) 
(hp_closed : IsClosedMap p) (h_compact : âˆ€ y âˆˆ Y, IsCompact (p â»Â¹' {y}))(hY_compact : IsCompact Y) : IsCompact X(hYc : IsCompact Y){X : Type*} [TopologicalSpace X] [CompactSpace X]{X Y : Type*}[TopologicalSpace X] : {Y : Type*} [TopologicalSpace Y] := 
countably_compact X := âˆ€ (U : â„• â†’ set X), (âˆ€ n, is_open (U n)) â†’ (X âŠ† â‹ƒ n, U n) â†’ âˆƒ (F : finset â„•), X âŠ† â‹ƒ n âˆˆ F, U n{X : Type*} [TopologicalSpace X] [T1Space X] : theorem countably_compact_iff_limit_point_compact {X : Type*} [TopologicalSpace X] :
  countably_compact X â†” (âˆ€ (A : Set X), Infinite A â†’ âˆƒ (x : X), x âˆˆ closure A) := := 
{X : Type*} [MetricSpace X]{f : X â†’ X} (h : âˆ€ x y : X, d (f x) (f y) = d x y)(is_isometry f){X : Type*} [MetricSpace X] [CompactSpace X] {f : X â†’ X} (h : is_isometry f) : (bijective f) (homeomorphism f) := 
(Set.Icc 0 1) ^ Ï‰ : Â¬LocallyCompactSpace (UniformSpace X) := 
(h : âˆƒ (f : â„• â†’ Type), âˆ€ n, f n = X)(h : âˆ€ (X : Type), âˆƒ (s : Set X), Countable s âˆ§ Dense s) : (h : âˆƒ (s : Set X), Countable s âˆ§ Dense s) := 
{X : Type*} [TopologicalSpace X] [RegularSpace X]âˆ€ (x y : X), : âˆ€ (x y : X), âˆƒ (U V : Set X), IsOpen U âˆ§ IsOpen V âˆ§ x âˆˆ U âˆ§ y âˆˆ V âˆ§ closure U âˆ© closure V = âˆ… := 
orderTopology : Regular H := 
(h2 : T2Space (Î  i, X i))(h : âˆ€ i, Nonempty (X i))âˆ€ i, T2Space (X i) : âˆ€ i, X i := 
(h2 : NormalSpace (Î  i, X i))(h3 : âˆ€ i, NormalSpace (X i))(h : âˆ€ i, Nonempty (X i)) : (Î  i, X i) := 
{X : Type*} [TopologicalSpace X] (hX : LocallyCompactSpace X) (hX' : T2Space X) : [TopologicalSpace X] [RegularSpace X] (h : âˆ€ x A, IsClosed A âˆ§ Â¬ x âˆˆ A â†’
  âˆƒ (f : X â†’ I), Continuous f âˆ§ f x = (1 : I) âˆ§ f '' A = {0}) := 
{X : Type*} [TopologicalSpace X] [CompactSpace X] [T2Space X](X1 X2 : Set X) (hX1 : IsClosed X1) (hX2 : IsClosed X2) (hUnion : X = X1 âˆª X2)(MetrizableSpace X1) (MetrizableSpace X2) : MetrizableSpace X := 
{X : Type*} [MetricSpace X] {Y : Type*} [MetricSpace Y][CompleteSpace Y]{A : Set X}{f : A â†’ Y} (hf : UniformContinuous f) : âˆƒ! g : Closure A â†’ Y, Continuous g âˆ§ UniformContinuous g âˆ§ âˆ€ x âˆˆ A, g x = f x := 
{n : â„•} (h : âˆ‘ i in (range (n - 1)), 1 / (i + 2))Â¬(âˆƒ n : â„•, a = n) : âˆ€ n : â„•, 1 < n â†’ Â¬(âˆƒ m : â„¤, âˆ‘ i in range (n - 1), 1 / (i + 2) = m) := 
{a : â„¤} (h : a â‰  0)(n m : â„•) (hnm : m < n) : (a^2^n + 1, a^2^m + 1) = if a % 2 = 0 then 2 else 1 := 
 : theorem square_free_sum_diverges : Â¬ âˆƒ (S : â„), âˆ€ Îµ > 0, âˆƒ N : â„•, âˆ€ n > N, (âˆ‘' k in {k : â„• | square_free k}, 1 / (k : â„)) < S + Îµ :=
begin
  -- proof goes here
end := 
 : Â¬ âˆƒ x y : â„¤, 3*x^2 + 2 = y^2 := 
Â¬ Nat.Prime n(n-1)! â‰¡ 0 [MOD n](n â‰  4) : (n - 1)! â‰¡ 0 [MOD n] (n â‰  4) := 
{p t : â„•} (hp0 : p.Prime) (hp1 : p = 4*t + 1)IsPrimitiveRoot a p : IsPrimitiveRoot a p â†” IsPrimitiveRoot (-a) p := 
{p : â„•} (hp : âˆƒ n : â„•, p = 2^n + 1 âˆ§ p.Prime) : IsPrimitiveRoot 3 p := 
âˆ‘ i in finset.range p, i ^ k(hl : Â¬ (p - 1) âˆ£ k)(hpk : p - 1 âˆ£ k)âˆ‘ i in finset.range p, i ^ k â‰¡ 0 [MOD p] (hl : Â¬ (p - 1) âˆ£ k)âˆ‘ i in finset.range p, i ^ k â‰¡ -1 [MOD p] (hpk : p - 1 âˆ£ k) : {p : â„•} (hp : Nat.Prime p) := 
{x : â„•} (h0 : âˆƒ x, x^4 â‰¡ 2 [ZMOD p]){p : â„•} (h0 : p â‰¡ 1 [ZMOD 4])(h : âˆƒ A B : â„•, p = A^2 + 64 * B^2)âˆ€ {p : â„•}, (âˆƒ x : â„•, x^4 â‰¡ 2 [ZMOD p]) â†” (p â‰¡ 1 [ZMOD 4] âˆ§ âˆƒ A B : â„•, p = A^2 + 64 * B^2) : {p : â„•} := 
sin (Real.pi / 12)IsAlgebraic â„š : IsAlgebraic â„š (sin (Real.pi / 12)) := 
{f : â„ â†’ â„} (hf : ContDiff â„ âŠ¤ f)(hf3 : f 0 = 0)(hf4 : f 1 = 1)(hf2 : âˆ€ x : â„, 0 â‰¤ f x) : âˆƒ n : â„•, âˆƒ x : â„, 0 < n âˆ§ fderiv â„^[n] f x < 0 := 
âˆƒ a : â„,(x : â„• â†’ â„) (hâ‚€ : x 0 = 1) (hâ‚ : x 1 = a) (hâ‚‚ : x 2 = a) (hâ‚ƒ : âˆ€ n â‰¥ 2, x (n + 1) = 2 * x n * x (n - 1) - x (n - 2)) : âˆ€ n, x n = 0 â†’ âˆƒ p, âˆ€ m, x (m + p) = x m := 
{p q r : â„•} {G : Type*} [Group G] [Fintype G] : âˆ€ (j k : â„•), j â‰  k â†’ is_coprime (P j) (P k) := 
 : âˆƒ! (a n : â„•), a^(n + 1) - (a + 1)^n = 2001 := 
(f : â„ â†’ â„)(hf : ContDiff â„ 3 f)(hf3 : âˆ€ x, 0 < f x âˆ§ 0 < f' x âˆ§ 0 < f'' x âˆ§ 0 < f''' x)(hf4 : âˆ€ x, f''' x â‰¤ f x) : (hf5 : âˆ€ x, f' x < 2 * f x) := 
âˆ€ (a b c : â„¤), : âˆƒ n : â„•, n > 0 âˆ§ âˆƒ a b c : â„¤, Â¬ âˆƒ k : â„¤, k^2 = n^3 + a * n^2 + b * n + c := 
